Day9 | LC28，LC459



KMP算法：
 1. KMP算法解决字符串匹配的问题（当不匹配的时候，不是从头再去匹配，而是利用之前已经匹配的内容）

 2. 前缀： aabaaf 前缀是包含首字母，不包含尾字母的全部子串。a, aa, aab, aaba, aabaa.

    后缀：不包含首字母的全部子串。

 3. 最长**相等**前后缀：前缀和后缀公共的长度

 4. 前缀表：**它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

 5. 前缀表匹配过程：在遇到不匹配的时候，找到不匹配位置之前这部分字串的最长相等前后缀，也就是看**不匹配位置前一位的前缀表的值**。因为下标是从0开始，所以这个**值就是重新开始匹配的位置。**（我们要跳到前缀的后面的位置开始匹配）

 6.  next数组/prefix数组：next数组可以是前缀表，也可以是前缀表统一减一或者右移一位，初始位置为-1。

​	

​	

​	这篇blog很好：

​	https://blog.csdn.net/yearn520/article/details/6729426

​	难点总结：

  1. i其实相当于不断在后面新加入字符。如果这个i对应的字符的前一个字符的prefix是0的话，说明前面部分没有最长公共前后缀，所以仅仅需要和字串的第一个字符比较就可以。同理，如果是1，则和第二个字符进行比较。依次类推。所以比较相等的情况下，其实就是继承前面的对称性的过程（前面的基础上+1）

  2. 仔细想想，你现在不匹配位置前面有一个子串，因为你的不匹配位置是紧挨着子串后缀末尾的。所以寻找后缀末尾的Prefix的值，得到最大公共前后缀的长度。然后去对应位置，可以确保前后缀部分相同，你只需要比较不匹配位置和前缀后第一个位置next[i-1] (j)的值。

  3. 如果不相等的时候，说明不能继承前面的对称性了，所以需要寻找前面字符串的最大对称程度。就开始不断往前寻找，一直寻找到头或者找到相等的位置。其实就是在j所在之前的子串中继续去找对称，就是j-1包括j-1到头的子串。 注意，回退不是j = j -1, j = j -1 就又是依次回退了。

     例如有(abad)(abac)

     比如现在到了最后一个位置c的比较，看c前面位置a,它所含的最长子串长度为3，所以去到3的位置，为d。进行比较，发现不相同。此时d前后有刚刚表明的长度为3的前后缀aba，此时想再去d前面的子串aba中找对称，如果能找到,就是一个大的对称中套了一对小的对称，此时小对称的前缀肯定和c前面的相同。

     

```C++
	void getNext(int* next,const string& s){
        //1.初始化，定义指针i，i用来遍历字符串，i其实相当于不断在后面新加入字符，也就是后缀的末尾。
        next[0] = 0;
        //i初始化为1
        for(int i = 1; i < s.size(); i++)
        {
            int j = next[i-1]; // 看i之前的字串的最大公共前后缀的长度。见难点1和2分析。         	
            //不相等的时候，就开始往前回退，一直到字符串开头或者比较相同的位置
            while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作          
                j = next[j - 1]; // 找子对称的情况
            }
            //相等的情况，继承前面的对称性的过程（前面的基础上+1）或者是 找到了新的匹配位置（子对称）
            if (s[i] == s[j]) {
               next[i] = j + 1; // j 从开始，也表示了最长公共前后缀的长度
            }
            //一直遍历到开头都没找到
            else
            {
                next[i] = 0;
            }            
        }
        
	}
```





LC28

​	题目链接：[Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)

​	解题思路：
  1. 暴力解法

     ```C++
     class Solution {
     public:
         int strStr(string haystack, string needle) {
             if(needle.size() == 0) return 0;
           
             int j = 0;
             for(int i = 0; i < haystack.size(); i++)
             {
                 int start = i;
                 while(haystack[start] == needle[j] && j < needle.size())
                 {
                     j++;
                     start++;
                 }
                 if(j == needle.size())
                 {
                     return( start - needle.size() );
                 }
                 else
                 {
                     j = 0;
                 }
             }
             return -1;
             
         }
     };
     ```

     

	2. KMP算法（太难了）

​	

​	总结：

	1. C++新建数组方法：
   
   int staticArray[10]; // 静态分配的整数数组，大小为10
   
   int* dynamicArray = new int[10]; // 动态分配的整数数组，大小为10。用完需要delete[] dynamicArray;
   
   std::vector<int> vec(10);





LC459

​	题目链接：[Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/)

​	解题思路：

  1. 暴力解法

     就是枚举不同长度的子串，从1开始，枚举到n/2。注意，子串的第一个字母就是整个字符串的开头字母。 注意j开始的位置正好就是第二个判断子串的第一个字母的位置。开始从这个位置判断，判断条件则是减去枚举的长度的位置与当前位置。 

     注意一定要加 if(n % i == 0)，只有n是i的倍数，下面的判断才有意义。不然会出现错误判断的情况

     ```
     class Solution {
     public:
         bool repeatedSubstringPattern(string s) {
             int n = s.size();
             bool flag = false;
             
             for(int i = 1; i <= n/2; i++)// 从字符长度为1开始枚举,子串的开头是第一个字母
             {
                if(n % i == 0)
                {
                
                     //j就是要去判断的第二个子串的开头位置。
                     int j = i;
             
                     for(; j < n; j++)
                     {
                         if(s[j] != s[j-i])
                         {
                             break;
                         }
                     } 
                     if(j == n )
                     {
                    
                         flag = true;
                     }
                }
             }
             if(flag)
             {
                 return true;
             }
     
             return false;
         }
     };
     ```

     

  2. 数学巧解

     如果一个字符串内部是由重复子串组成，那么s+s,一定可以内部再找到一个字符串s.

     注意这种解法要去除s+s的首位字符，确保我们搜索到的结果是拼接出来的新的s.

     

     

  3. KMP算法

     如果一个字符串是重复子串组成，那么它的重复子串就是这个字符串的最长相等前后缀不包含的部分，也就是整个字符串减去最长相等前后缀以后剩余的部分。

     所以就是用总长度，减去最长相等前后缀的长度，剩下的长度，可以被原长度整除，就说明字符串是重复子串组成的。

     





总结：

	1. string 中有erase()函数，参数是iterator.  还有find()函数，判断条件是ss.find() != std::string::npos. 返回它在字符串中第一次出现的位置

![](https://github.com/SwordXiaoJ/Algo/blob/main/images/Day9_KMP.png)

1. t0 = k0, t1 = k1.因为t0原来对应的是s0,k0对应的是s2。 所以s0=s2,同理，s1=s3.   所以s01 = s23
2. 因为在字符串同一个位置，所以t2=k0,t3=k1.所以k01=t23.
3. 同步骤1，t2=k2,t3=k3, 又对应到原来字符串，所以s2=s4,s3=s5,所以s23 = s45.
4. 重复以上步骤
5. 所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。



数组总结：

 1. **其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

 2. for循环里调用库函数erase来移除元素，这其实是O(n^2)的操作，因为erase就是O(n)的操作。一般可以考虑使用双指针来解决

 3. 其实**当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章**。只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。

 4. 

    

​	
