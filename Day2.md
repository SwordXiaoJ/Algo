Day2 | LC977,LC209,LC59



LC977

​	题目链接 [[Squares of a Sorted Array]](https://leetcode.com/problems/binary-search/)

​	解题思路 

1. 第一反应是使用暴力解法，遍历以后，使用快排函数。但是明显不是优解
1. 考虑到最大值每次都只会出现在数组的两头，所以考虑使用双指针法，从两头开始比较。建立一个新数组存储结果

​	问题

​		此题一次AC，无问题

​	总结

 	1. 此题主要是锻炼使用双指针法的应用。注意此题有一个十分重要的条件，就是原始数组有序。
 	2. 注意最后的返回值数组是从大到小，所以结果数组要从大到小更新。





LC209

​	题目链接 [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

​	解题思路 

​		滑动窗口思想（双指针）

​		1.  主要还是使用一个for循环来完成两个for循环的工作。**注意循环里面的下标是终止位置。**

​                          Key: 如果循环里面的下标是起始位置，那么还是需要遍历起始位置后面的所有位置作为终止位置，和暴力解法没有区别。

​                2.  核心：如何移动起始位置？        主要是判断这个区间内的合是否大于目标值，如果大于，则移动起始位置来缩小窗口大小寻找最小的长度 

​	问题

 	1. 第一次提交的时候，直接在滑动过程中将result = endIndex - startIndex + 1。过了一部分测试用例，但是没有考虑到在找到结果以后，还要遍历完整个数组，所以结果有可能被覆盖。所以需要加上判断，来判断新的结果是否小于已经获得的结果，如果满足小于的条件，再进行覆盖。
 	2. 再加了判断以后，在Test以后，发现不能将result的初始值设置为0。如果设置为0，所有的长度都不满足筛选条件，结果会一直返回0。此时考虑使用INT_MAX,最后在返回结果的时候，加一个判断就可以了。



​	总结

1. 题目主要是学习滑动窗口的思想。我主要的思考方式是先考虑到暴力解法，然后考虑可不可以使用一个循环来完成优化，所以想到双指针的方法。
2. 遇到的主要问题是在实际做题的过程中，注意一些初始值的设置。考虑它是否可以完成题目要求。常见的初始值除了0以外，还有INT_MAX,INT_MIN等。



LC59

​	题目链接 [Spiral Matrix II](https://leetcode.com/problems/minimum-size-subarray-sum/)

​	解题思路 

​		在仿真过程中，坚持循环不变量。即坚持相同的处理原则，对于每一条边来说。

​	总结：

​		1. 解法一：使用循环不变量，每条边处理的时候，仅处理第一个节点，不处理最后一个节点。在循环四条边的过程中，由于使用了一组i和j来控制旋转，所以容易搞混。

​		2. 解法二： 使用四条线，分别对应上下左右来控制循环。注意的是右边界线和下边界线均为n-1,即保证可以数组可以访问到。这个方法有点违背循环不变量的原则，是考虑不断收缩边界来完成填充。主要是参考Leetcode解法。





Additional:

LC885

​	题目链接 [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/)

​	解题思路：

​		本题仍然是模拟，主要是观察规律，观察到规律是移动步数依次为1122334455，就是每移动两次相同的步数，就会给移动步数+1。而且移动的方向以此是右，下，左，上。

​	总结：
​		学会在模拟中，新建二维数组来表示方向。

```C++
 vector<vector<int>> directions = {{0,1},{1,0},{0,-1},{-1,0}};
        //右，下，左，上
```

​       

在数组中，如果结果初始化为

`vector<vector<int>> result`;

则使用

`result.push_back({1,2});`

添加元素



如果初始化为

`vector<vector<int>> result(4,vector<int>(4,0))`;

则使用

`result[0][0] = 1;`

添加元素



