Day14 LC144,LC94,LC145



二叉树基本知识：
 - 二叉树种类

   - 满二叉树：只有度为0和度为2的节点，且度为0的节点在同一层

   - 完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。

       堆就是一个完全二叉树，保证父子节点的关系

   - 二叉搜索树，有序树，从这开始的树，是有数值的。（左小右大）

     - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
     - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
     - 它的左、右子树也分别为二叉搜索树

   - 平衡二叉搜索树（AVL）

     - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

     

   

 - 二叉树存储方式

   - 链式存储： 指针

     最熟悉的，就是每个节点有节点元素以及左右指针

   - 顺序存储：数组

      给二叉树从上到下编号，按照数组下标依次存储。**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

 - 二叉树遍历方式：

   - 深度优先：往深处走，到达叶子节点再回头。使用栈
     - 前序：中左右
     - 中序：左中右
     - 后序：左右中
   - 广度优先：层序遍历，使用队列



栈是递归的一种实现结构。



前序遍历：[Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

中序遍历：[Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)

后序遍历：[Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)



深度优先遍历：

递归遍历：

​	递归三部曲

1. 确定递归函数参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. 确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. 确定单层递归逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



迭代遍历：

​	前序：用一个栈很简单就可以实现，注意。

​	中序：中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。** **借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素**

​	后序：修改前序代码，调整代码左右顺序，然后reverse就可以





迭代统一写法：

 1. 无论如何，先从根节点开始，一直向左走，把遍历的节点放进栈中。

 2. 然后while(!stk.empty())开始，取出栈顶元素，然后判断该元素的右孩子，如果有右孩子，重复从右孩子开始，一直往左走，并把遍历的节点加入到stk中。

 3. 前中序遍历，在这种框架中，仅仅就是将元素添加到result的地方不同。

    前序：在一开始遍历根节点的左边入栈的时候添加，以及在stk弹出元素的过程中，有右节点，且右节点的左边入栈的时候添加。

    中序：在stk弹出元素的时候，添加。

    后序：比较复杂，但是大框架不变。(后序遍历不一样，因为前序和中序的时候，在以中左入栈以后，当top的时候，其实已经处理完左子树了，中也处理完了，所以直接pop节点就可以)

    ​      所以要去判断要pop的这个节点的情况：（引入一个prev，记录这个节点处理之前的上一个处理节点）

       1. 这个节点的左右子树都为空，说明是叶子节点，直接pop,并且添加到结果集中。

       2. 这个节点的上一个处理节点为该节点的左孩子，且这个节点无右孩子。

       3. 这个节点的上一个处理节点为该节点的右孩子，说明右子树处理完了，左子树在这个之前处理，肯定也遍历完了，所以pop。如果不满足条件，去判断该元素的右孩子，如果有右孩子，重复从右孩子开始，一直往左走，并把遍历的节点加入到stk中。这边加了一个大的if else的判断

          

    

​	
