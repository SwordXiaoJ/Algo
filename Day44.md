Day 44

​	完全背包问题

  1. 与0-1背包不同点就是每个物品有无限个，也就是一个物品可以放入背包多次。

  2. 主要区别也就是遍历顺序和转移方程

     - 二维数组：

       转移方程不一样：

       ​	完全背包在如果要加入这个元素的情况下，依然是从下标为0-i的区间中取元素，因为可以重复取元素

       ```
       dp[i][j]=max(dp[i−1][j],dp[i][j−w[i]]+v[i])  //完全背包
       
       dp[i][j]=max(dp[i−1][j],dp[i-1][j−w[i]]+v[i])  //0-1背包
       ```

       遍历顺序一样：

       ​	都是正序遍历。

       ​	先遍历物品还是先遍历背包，都可以，不影响。

     - 一维数组：

       转移方程一样：

       ```
       dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
       ```

       遍历顺序不一样：

       ​	**0-1背包，先物品，后背包。背包倒序遍历**

       ​	纯完全背包（求最大值问题），物品和背包顺序无所谓。背包正序遍历（因为一个物品可以加入多次）。

       ​	在0-1背包中，不能换背包和物品的顺序的原因是，因为背包要求倒序，如果换了，每次背包永远都只会放入一个元素。

       ​	在完全背包中，背包是正序了，就不存在这个问题。因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。



完全背包问题中，如果要求排列/组合数量：
       **先遍历物品，后遍历背包，得到的是组合。**

​       **先遍历背包，后遍历物品，得到的是排列。**

LC518

​	题目链接：[Coin Change II](https://leetcode.com/problems/coin-change-ii/)

​	解题思路：

​		1. 基本的完全背包思路，注意遍历顺序的问题。

​		   因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。本题是求凑出来的方案个数，且每个方案个数是为组合数。

​		 如果先遍历物品，再遍历背包，那么例如coins[0] = 2; coins[1] = 3; 那么肯定是先把0加入计算，再把1加入计算。所以得到的肯定就是{1，5}这种情况，不会出现{5，1}的情况

​		如果先遍历背包，再遍历物品。背包的每一个容量值，都经过了两个coin的计算，可能会出现{5，1}和{1，5}两种情况。

​		**所以先遍历物品，后遍历背包，得到的是组合。**这样做的原因是，我们希望每次只考虑当前物品对所有容量的贡献，这确保了物品的组合不会因为选择的顺序而重复计数。

​		**先遍历背包，后遍历物品，得到的是排列。**这样做的原因是，我们希望每次考虑到达特定容量时所有物品的贡献，这样就能捕捉到不同选择顺序的不同排列。

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        //dp数组
        //dp[j]:表示凑成金额为j的货币组合数为dp[j]
        vector<int> dp(amount+1,0);

        //递推公式
        //dp[j] = dp[j] + dp[j-coins[i]]

        //初始化
        dp[0] = 1;

        //遍历顺序
        for(int i = 0; i < coins.size(); i++)
        {
            for(int j = coins[i]; j <= amount; j++)
            {
                dp[j] = dp[j] + dp[j-coins[i]];
            }
        }
        return dp[amount];       
    }
};
```



LC377

​	题目链接：[Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)

​	解题思路：

  1. 看起来是组合问题，但是分析Example，发现是排列问题。思路已经在上一道题中分析过了

     ```C++
     class Solution {
     public:
         int combinationSum4(vector<int>& nums, int target) {
             //dp[j]表示组成target为j的排列个数为dp[j]
             vector<int> dp(target+1,0);
     
             //递归公式
             //dp[j] = dp[j] + dp[j-nums[i]];
     
             //初始化
             dp[0] = 1;
     
             //遍历顺序，本题是求排列，所以是先背包，后物品。又因为是完全背包，所以是正序
             for(int j = 0; j <= target; j++)
             {
                 for(int i = 0; i < nums.size(); i++)
                 {
                     if(j >= nums[i] && dp[j] < INT_MAX - dp[j - nums[i]])
                     {
                         dp[j] = dp[j] + dp[j-nums[i]];
                     }
                 }
             }
     
             return dp[target];
            
         }
     };
     ```

     
